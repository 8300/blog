
<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
</head>
<h1>gcc_note.html</h1>

<p style="white-space:pre-wrap">


</p><h2>system</h2><p style="white-space:pre-wrap">

023	->octonary number system	
0x32	->16 number system	

</p><h2>error</h2><p style="white-space:pre-wrap">
	</p><h3>conflicting type for</h3><p style="white-space:pre-wrap">
1,没有函数声明，且函数定义在主函数之后；
2.头文件的被循环引用，在引用时考虑清楚包含顺序;
3.头文件函数声明和函数定义参数不同
4.函数使用的参数类型是自定义类型（如结构体），而自定义类型的定义在函数的声明和函数定义之间，由于在函数声明时，结构体并没有被定义，不被系统识别为结构体，而后面定义函数时，结构体已经定义，系统将其识别为结构体，导致系统认为声明和定义使用的是不同的参数类型；所以才会出现上述问题；
5.在linux中，编译头文件，会出现一个中间的预编译文件（.h.gch），当再次编译整个文件时，如果该文件(.h.gch)存在，则会直接使用该文件(.h.gch)，而不会再编译.h文件，此时，如果你改动了.h文件，而继续编译，则会造成声明和定义不一致的现象，虽然在文件里显示声明和定义是一致的，但是实际上系统编译时并不会使用你改动后的文件(.h)，而是直接使用你修改前编译生成的.h.gch文件；(这个错误一般很难发现，如果发现自己目录下有.h.gch文件，则一定要及时更新；）
	</p><h3>编译链接静态库的符号未定义问题</h3><p style="white-space:pre-wrap">
如果A.a依赖B.a，则先-lA 然后-lB
	</p><h3>function undeclared</h3><p style="white-space:pre-wrap">
warning but the return value from void to unsigned int
If the function is undeclared in .h file. return int type.
	</p><h3>no input files</h3><p style="white-space:pre-wrap">
The mounted Windows file cannot be set to executable
	</p><h3>gnueabihf/bin/ld: cannot find -lhcnetsdk</h3><p style="white-space:pre-wrap">
solution:file lib/libhcnetsdk.so	
	</p><h3>g</h3><p style="white-space:pre-wrap">
lib/libhcnetsdk.so: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, stripped	
target:arm != intel80386	
	</p><h3>No such file or path</h3><p style="white-space:pre-wrap">
sudo apt install lib32ncurses-dev
	</p><h3>error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</h3><p style="white-space:pre-wrap">
sudo apt-get install lib32z1

</p><h2>lib</h2><p style="white-space:pre-wrap">
	</p><h3>link path</h3><p style="white-space:pre-wrap">
-Wl,-rpath /usr, /usr/local	
### check lib
readelf -d example.so	

## tool

readelf	: -a xxx 	//Display information about the contents of ELF format files
objdump	: -s 	//Display information from object [file(s)].
nm	://List symbols in [file(s)] (a.out by default).
strip	://Removes symbols and sections from files

## pointer

unsigned char uu[100];	
{&uu[49]}	
(char *)(&uu[49])	
char *p;	
char a;	
a=*p;	
(int *)p;	
(unsigned int *)(&uu[49]);	
unsigned int b;	
b=*(unsigned int *)(&uu[49]);	
unsigned int c;	
*(unsigned int *)(&uu[49])=c	
10 pointer 	:int *a[10];	
int b[10];	:int (*a)[10];	
int b(int m);	:int (*a)(int);	
10 pointer int b(int m);	:int (*a[10])(int);	

## macro

### # and ##
#	:converts arguments to strings;	
##	:connecting two parameters;	
eg:	
#define STR(arg) #arg 	//STR(hello) ->	”hello”	
#define NAME(y) name_y 	//NAME(1) -> name_y	
#define NAME(y) name_##y	//NAME(1) -> name_1	
#define DECLARE(name, type) typename##_##type##_type	
	//DECLARE(val, int) ->int val_int_type	
### error
#define S(r) r*r	//error
area=S(a+b);	
area=r*r;	
area=a+b*a+b;	
#define S(r) ((r)*(r))	//true	

## static

1.static stroe	
function of the internal: local variable	
source file	:global variable	
2. internal link	
static function	:only used in source file	

## const

The value cannot be modified.	
const int a = 5;	//true	
const int b; b = 10;	//true	
const int b; b = 10; b= 3	//false	
const int *ptr;	//ptr = &(const int m).	
int *const ptr;	//ptr is const; ptr = const &(int m)	
const int *const ptr;	//ptr = const &(const int m)	
int fun(const int a);int fun(const char *str);	
const char *getstr(void);const *str= getstr();	
const int getint(void); const int a =getint();	

## volatile

it can change value any time a user wants it to be changed or when another thread is running but using the same variable.	
It tells the compiler that the value of the variable may change at any time--without any action being taken by the code the compiler finds nearby.	

## extern

the function is defined elsewhere	
extern int a; 
extern int *p;
extern int array[];
extern void fun(void);	
1 .extern "c"	
#ifdef __cplusplus
extern “C”
{
#endif	
extern void fun(int a, int b);	
#ifdef __cplusplus	
}	
#endif	
extern "C" doublesqrt(double);	
extern "C"	
{	
double sqrt(double);	
int min(int, int);	
}	
extern "C"	
{	
#include <cmath>	
}	

## struct

struct tag	
{	
char a;	
int b;	
}x = {‘A’, 1};
struct tag
{
char a;
int b;
};
struct tag x = {‘A’,1};
2.GNU C:
struct tag
{
char a;
int b;
}x =
{
.a = ‘A’,
.b =1;
};
2.
struct tag
{
char a;
int b;
};
struct tag x =
{
.a= ‘A’,
.b=1,
};
2.
struct tag
{
char a;
int b;
}x;
x = {‘A’,1}; //false

## bit field

struct st1 
{
unsigned char a:7;//7 bit
unsigned char b:2;//2 bit
unsigned char c:7;//7 bit
}s1;
sizeof(s1) = 3.
struct st2
{
unsigned int a:31;
unsigned int b:2;
unsigned int c:31;
}s2;
sizeof(s2) = 12;

## argument

### 0 size parameter
typedef struct st {
int a;
int b;
char c[0];
}st_t;
sizeof(st_t) = 8;char c[0] size is 0.
#define SIZE 100
st_t *s = (st_t *)malloc(sizeof(st_t) + SIZE);
### Variable Argument Lists
stdarg.h
macro:va_start,va_arg,va_end	
typedef char *va_list;
#define va_start(ap, A) (void)((ap) = (char *)&(A) + _Bnd(A, _AUPBND))	
#define va_arg(ap, T) (*(T )((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND)))	
#define va_end(ap) (void)0
int print(char *format, …)

## function

__cdecl
int __cdecl func(int a, int b);
### 1.//inline
Inline Function are those function whose definitions are small and be substituted at the place where its function call is happened. 

## memory

1.//malloc(0) free can be used security;

## system("pause");

=getchar();

## notice

charr *str = (char *)malloc(100); 
strcpy(str, "hello" );	
free(str);	
str = NULL;	//notice

## floating point numbers compared to zero values

const float EPSINON = 0.00001;	
if ((x >= - EPSINON) && (x <= EPSINON)	                

## sizeof

32bit system
char  str[] = “Hello” ;	//6	
char   *p = str ;	//4	                    
i nt    n = 10;		//4	                                
void Func ( char str[100]) {}	//4	
void * p = malloc( 100 );	//4	                                               
typedef union {long i; int k[5]; char c;} DATE;	//5*sizeof(int)	:20
15、struct name1{
char str;
short x;
int num;
}	//8

## char *

char* s="AAA";	//error s is constant	
s[0]='B';	//error	
cosnt char* s="AAA";//true	
*((void (*)())0x100000)();//function run	
#define swap(x, y) (x)=(x)+(y);(y)=(x)–(y);(x)=(x)–(y);

## 2 power to power

(a)&(a-1)?’n’:’y’);	
//---------------------end-----------------------------
</p>
